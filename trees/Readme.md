## 🌐 Socials:
[![LinkedIn](https://img.shields.io/badge/LinkedIn-%230077B5.svg?logo=linkedin&logoColor=white)](https://www.linkedin.com/in/atiladeoke/)

# 💻 Tech Stack:
![C++](https://img.shields.io/badge/c++-%2300599C.svg?style=for-the-badge&logo=c%2B%2B&logoColor=white)
![Python](https://img.shields.io/badge/python-3670A0?style=for-the-badge&logo=python&logoColor=ffdd54)

## What is a Tree?
A tree is a hierarchical data structure consisting of nodes.
Root → The topmost parent node.
Child → A node that descends from another node.
Parent → A node with one or more children.
Leaf → A node with no children.
Height → Distance from the root to the deepest leaf.
Depth → Distance of a node from the root.

## Types of Linked Lists:
## Binary Tree:
Each node has at most 2 children.

## Binary Search Tree (BST) 
→ Left child < parent < right child.

## Full Binary Tree
→ Every node has either 0 or 2 children.

## Complete Binary Tree 
→ All levels are filled except possibly the last.

## Balanced Tree (AVL/Red-Black)
→ Height kept minimal for fast lookup.

Heap → A complete binary tree used for priority queues (min/max heap
## 📚 LeetCode Practice
To enhance my problem-solving skills, I follow the [Neetcode Roadmap](https://neetcode.io/roadmap) for tackling LeetCode problems. This resource provides a structured approach to learning data structures and algorithms, helping me to prepare for technical interviews and improve my coding proficiency.

## 📚 Commomn Patterns
## Breadth First Search:
Explore level by level using a queue.
Example: shortest path in an unweighted graph.
## Depth First Search:
Explore as far as possible down one path before backtracking.
Implemented with recursion or stack.
Variants: Preorder, Inorder, Postorder for trees.
## Recursion:
Solve a problem by breaking it into smaller subproblems.
Needs:
Base case → stop condition.
Recursive case → call the function on smaller input.

## When stuck:
## Problem-Solving Approach

1. **Learn the Basics**
   - Understand fundamental concepts.

2. **Look for Real-World Implementations**
   - Find examples of how these concepts are applied in real scenarios.

3. **Visualize with Pen and Paper**
   - Sketch diagrams or flowcharts to clarify your understanding.

4. **Implement from Scratch**
   - Write your own code to reinforce what you’ve learned.

5. **Learn the Built-In Libraries**
   - Familiarize yourself with libraries and frameworks that can streamline your coding process.

6. **Solve Simple Problems**
   - Start with easier problems to build confidence and skill.

7. **Tackle Hard Problems**
   - Gradually challenge yourself with more complex problems to further your expertise.

---

> **Tip:** Keep practicing and iterating on this process to continually improve your problem-solving skills!
