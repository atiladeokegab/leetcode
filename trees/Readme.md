## ğŸŒ Socials:
[![LinkedIn](https://img.shields.io/badge/LinkedIn-%230077B5.svg?logo=linkedin&logoColor=white)](https://www.linkedin.com/in/atiladeoke/)

# ğŸ’» Tech Stack:
![C++](https://img.shields.io/badge/c++-%2300599C.svg?style=for-the-badge&logo=c%2B%2B&logoColor=white)
![Python](https://img.shields.io/badge/python-3670A0?style=for-the-badge&logo=python&logoColor=ffdd54)

## What is a Tree?
A tree is a hierarchical data structure consisting of nodes.
Root â†’ The topmost parent node.
Child â†’ A node that descends from another node.
Parent â†’ A node with one or more children.
Leaf â†’ A node with no children.
Height â†’ Distance from the root to the deepest leaf.
Depth â†’ Distance of a node from the root.

## Types of Linked Lists:
## Binary Tree:
Each node has at most 2 children.

## Binary Search Tree (BST) 
â†’ Left child < parent < right child.

## Full Binary Tree
â†’ Every node has either 0 or 2 children.

## Complete Binary Tree 
â†’ All levels are filled except possibly the last.

## Balanced Tree (AVL/Red-Black)
â†’ Height kept minimal for fast lookup.

Heap â†’ A complete binary tree used for priority queues (min/max heap
## ğŸ“š LeetCode Practice
To enhance my problem-solving skills, I follow the [Neetcode Roadmap](https://neetcode.io/roadmap) for tackling LeetCode problems. This resource provides a structured approach to learning data structures and algorithms, helping me to prepare for technical interviews and improve my coding proficiency.

## ğŸ“š Commomn Patterns
## Breadth First Search:
Explore level by level using a queue.
Example: shortest path in an unweighted graph.
## Depth First Search:
Explore as far as possible down one path before backtracking.
Implemented with recursion or stack.
Variants: Preorder, Inorder, Postorder for trees.
## Recursion:
Solve a problem by breaking it into smaller subproblems.
Needs:
Base case â†’ stop condition.
Recursive case â†’ call the function on smaller input.

## When stuck:
## Problem-Solving Approach

1. **Learn the Basics**
   - Understand fundamental concepts.

2. **Look for Real-World Implementations**
   - Find examples of how these concepts are applied in real scenarios.

3. **Visualize with Pen and Paper**
   - Sketch diagrams or flowcharts to clarify your understanding.

4. **Implement from Scratch**
   - Write your own code to reinforce what youâ€™ve learned.

5. **Learn the Built-In Libraries**
   - Familiarize yourself with libraries and frameworks that can streamline your coding process.

6. **Solve Simple Problems**
   - Start with easier problems to build confidence and skill.

7. **Tackle Hard Problems**
   - Gradually challenge yourself with more complex problems to further your expertise.

---

> **Tip:** Keep practicing and iterating on this process to continually improve your problem-solving skills!
